var thingy
println(thingy)

abstract class Animal {
    abstract fn sayHi(name)
}

class Cat : Animal {
    const type = "cat"
    var name
    var size = 10
    // age := 0
    
    fn init(thing) {
        println('yo from init', thing)
    }
    
    fn sayHi(to) {
        println("hi " + to)
    }
    
    fn setName(newName) {
        this.name = newName
    }
    
    fn getName() {
        return this.name
    }
    
    fn getSize() {
        return this.size
    }
    
    fn setSize(size) {
        this.size = size
    }
}

var cat = Cat('yort')
// cat.name = "Kiikii"; // TODO: This should cause an error.
cat.setName('Kiikii')
println('the name of the cat is:', cat.getName())

var sayHi = cat.sayHi;

sayHi("Skyler");
cat.sayHi('yeet')

println('Cat type is:', Cat.type)

println(cat)
println(cat.getSize())

/*

class Person {
    var name
    age := 0
    var id
    
    private var ssn
    const type = 'person'
    other ::= 'yeet'
    
    init(name, age, foo) {
        .name = name
        .age = age
        id = foo
    }
    
    private someFunc() {
        
    }
}

class Dude < Person {
    init(name, age, foo, stuff) {
        super.init(name, age, foo)
    }
}

class Nested {
    method() {
        fn function() {
            println(this);
        }

        function();
    }
}

Nested().method();

class CoffeeMaker {
    init(coffee) {
        this.coffee = coffee;
    }

    brew() {
        println("Enjoy your cup of " + this.coffee + ".");

        // No reusing the grounds!
        this.coffee = null;
    }
}

var maker = CoffeeMaker("coffee and chicory");
maker.brew();

class Oops {
    init() {
        fn f() {
            println("not a method");
        }

        this.field = f;
    }
}

var oops = Oops();
oops.field();
*/
